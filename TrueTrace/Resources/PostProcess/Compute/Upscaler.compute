#pragma kernel kernel_upsample
#include "../../GlobalDefines.cginc"
#include "UnityCG.cginc"

int source_width;
int source_height;

int target_width;
int target_height;

Texture2D<half4> Input;
Texture2D<half4> ThroughputTex;
SamplerState my_linear_clamp_sampler;
RWTexture2D<float4> Output;
RWTexture2D<float4> FinalOutput;
Texture2D<half4> PrevOutput;


half4 SGSRRH(float2 p)
{
    half4 res = Input.GatherRed(my_linear_clamp_sampler, p);
    return res;
}
half4 SGSRGH(float2 p)
{
    half4 res = Input.GatherGreen(my_linear_clamp_sampler, p);
    return res;
}
half4 SGSRBH(float2 p)
{
    half4 res = Input.GatherBlue(my_linear_clamp_sampler, p);
    return res;
}
half4 SGSRAH(float2 p)
{
    half4 res = Input.GatherAlpha(my_linear_clamp_sampler, p);
    return res;
}
half4 SGSRRGBH(float2 p)
{
    half4 res = Input.SampleLevel(my_linear_clamp_sampler, p, 0);
    return res;
}

half4 SGSRH(float2 p, uint channel)
{
    if (channel == 0)
        return SGSRRH(p);
    if (channel == 1)
        return SGSRGH(p);
    if (channel == 2)
        return SGSRBH(p);
    return SGSRAH(p);
}


#define OperationMode 3

#define EdgeThreshold 4.0/255.0

#define EdgeSharpness 2.0

////////////////////////
////////////////////////
////////////////////////

// ///////SGSR_GL_Mobile.frag/////////////////////////////////////////
// #if defined(SGSR_MOBILE)
half fastLanczos2(half x)
{
    half wA = x- half(4.0);
    half wB = x*wA-wA;
    wA *= wA;
    return wB*wA;
}
half2 weightY(half dx, half dy, half c, half std)
{
    half x = ((dx*dx)+(dy* dy))* half(0.5) + clamp(abs(c)*std, 0.0, 1.0);
    half w = fastLanczos2(x);
    return half2(w, w * c);
}

void SgsrYuvH(
    out half4 pix,
    float2 uv,
    float4 con1)
{
    int mode = OperationMode;
    half edgeThreshold = EdgeThreshold;
    half edgeSharpness = EdgeSharpness;
    if(mode == 1)
        pix.xyz = SGSRRGBH(uv).xyz;
    else
        pix.xyzw = SGSRRGBH(uv).xyzw;
    float xCenter;
    xCenter = abs(uv.x+-0.5);
    float yCenter;
    yCenter = abs(uv.y+-0.5);
    
    //todo: config the SR region based on needs
    //if ( mode!=4 && xCenter*xCenter+yCenter*yCenter<=0.4 * 0.4)
    if ( mode!=4)
    {
        float2 imgCoord = ((uv.xy*con1.zw)+ float2(-0.5,0.5));
        float2 imgCoordPixel = floor(imgCoord);
        float2 coord = (imgCoordPixel*con1.xy);
        half2 pl = (imgCoord+(-imgCoordPixel));
        half4  left = SGSRH(coord, mode);
        
        half edgeVote = abs(left.z - left.y) + abs(pix[mode] - left.y)  + abs(pix[mode] - left.z) ;
        if(edgeVote > edgeThreshold)
        {
            coord.x += con1.x;

            half4 right = SGSRH(coord + float2(con1.x,  0.0), mode);
            half4 upDown;
            upDown.xy = SGSRH(coord + float2(0.0, -con1.y), mode).wz;
            upDown.zw = SGSRH(coord + float2(0.0,  con1.y), mode).yx;

            half mean = (left.y+left.z+right.x+right.w)* half(0.25);
            left = left - half4(mean,mean,mean,mean);
            right = right - half4(mean, mean, mean, mean);
            upDown = upDown - half4(mean, mean, mean, mean);
            pix.w =pix[mode] - mean;

            half sum = (((((abs(left.x)+abs(left.y))+abs(left.z))+abs(left.w))+(((abs(right.x)+abs(right.y))+abs(right.z))+abs(right.w)))+(((abs(upDown.x)+abs(upDown.y))+abs(upDown.z))+abs(upDown.w)));
            half std = half(2.181818)/sum;
            
            half2 aWY = weightY(pl.x, pl.y+1.0, upDown.x,std);
            aWY += weightY(pl.x-1.0, pl.y+1.0, upDown.y,std);
            aWY += weightY(pl.x-1.0, pl.y-2.0, upDown.z,std);
            aWY += weightY(pl.x, pl.y-2.0, upDown.w,std);           
            aWY += weightY(pl.x+1.0, pl.y-1.0, left.x,std);
            aWY += weightY(pl.x, pl.y-1.0, left.y,std);
            aWY += weightY(pl.x, pl.y, left.z,std);
            aWY += weightY(pl.x+1.0, pl.y, left.w,std);
            aWY += weightY(pl.x-1.0, pl.y-1.0, right.x,std);
            aWY += weightY(pl.x-2.0, pl.y-1.0, right.y,std);
            aWY += weightY(pl.x-2.0, pl.y, right.z,std);
            aWY += weightY(pl.x-1.0, pl.y, right.w,std);

            half finalY = aWY.y/aWY.x;

            half max4 = max(max(left.y,left.z),max(right.x,right.w));
            half min4 = min(min(left.y,left.z),min(right.x,right.w));
            finalY = clamp(edgeSharpness*finalY, min4, max4);
                    
            half deltaY = finalY -pix.w;

            pix.x = saturate((pix.x+deltaY));
            pix.y = saturate((pix.y+deltaY));
            pix.z = saturate((pix.z+deltaY));
        }
    }
    pix.w = 1.0;  //assume alpha channel is not used

}
// #endif



[numthreads(16,16,1)]
void kernel_upsample (int3 id : SV_DispatchThreadID)
{
    if (id.x >= target_width || id.y >= target_height) return;
    
    float4 OutColor;
    float4 ViewportInfo = float4(rcp(float2(target_width, target_height)), float2(target_width, target_height));
    float2 uv = (id.xy + 0.5f) / float2(target_width, target_height);
    SgsrYuvH(OutColor, uv, ViewportInfo);
    Output[id.xy] =  OutColor;
}

#pragma kernel simpleblur
Texture2D<float4> Albedo;
Texture2D<float4> Albedo2;
[numthreads(16,16,1)]
void simpleblur (int3 id : SV_DispatchThreadID)
{
    float3 In = Input[id.xy];
    // float3 Max = -9999.0f;
    // float3 Min = 9999.0f;
    // for(int i = -1; i <= 1; i++) {
    //     for(int j = -1; j <= 1; j++) {
    //         if(i == 0 && j == 0) continue;
    //         In += Input[id.xy + int2(i,j) * 1.0f];
    //         Max = max(Max, Input[id.xy + int2(i,j) * 2.0f]);
    //         Min = min(Min, Input[id.xy + int2(i,j) * 2.0f]);
    //     }
    // }
    // In /= 9.0f;
    // In = clamp(In, Min, Max);

    #ifdef HDRP
        float3 SpecularAlbedo = 0;//Albedo2[int3(ipos,0)].xyz;
    #else
        float3 SpecularAlbedo = Albedo2[id.xy].xyz;
    #endif

    FinalOutput[id.xy] = float4(In * ((all((Albedo.SampleLevel(my_linear_clamp_sampler, id.xy / float2(target_width, target_height), 0).xyz + SpecularAlbedo) == 0) ? 1 : ((Albedo.SampleLevel(my_linear_clamp_sampler, id.xy / float2(target_width, target_height), 0).xyz + (max(SpecularAlbedo,0.04f) - 0.04f))))), 1);
}